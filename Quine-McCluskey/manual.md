## 1. 사용된 개념
- Quine-McClusky
K-map 방법으로는 변수의 개수가 많아지는 상황에 대해 적절하게 대처하기가 어렵다. 마치 변수
의 개수가 2개, 3개 정도면 실제 map을 그려 정해진 룰에 따라 변수를 합하여 처리할 수 있지만,
5개 혹은 6개 이상이 되면 3차원 이상에 해당하는 그림을 그려야 하는데, 이 부분에 대해서 코드
로 구현하는 것이 쉽지 않다. 따라서 본 보고서에서는 Quine-McClusky 방법을 사용한다. QuineMcClusky 방법은 아래 알고리즘에 따라 동작한다.
1) Input으로 들어오는 truth value를 2진수로 변환한다.
2) 각 2진수들에 대해 1의 개수를 세어준다.
3) 1의 개수가 0개부터 n(변수의 개수)개까지의 그룹으로 나눈다.
4) 1의 개수가 n개인 그룹은 n-1개인 그룹과 비교하여 비트 수가 1개 차이나는 조합을 찾는다.
5) 찾아진 조합은 따로 모으고, 아무 조합에도 포함되지 않는 truth value는 그대로 prime으로 간
주한다. (prime에 포함되면 minterm expression시에 출력된다.)
6) 찾아진 조합(한 쌍)은, 서로 다른 비트 ‘-‘로 변환한 뒤 합친다. (그 외 나머지 비트는 같으므로)
7) 6)으로 처리된 조합들에 대해 다시 3)-6) 과정을 반복한다. 서로 다른 비트를 합치는 과정에서
최대 1의 개수가 반드시 1개 줄어들기 때문에 전체 비트 수가 n개라면 최대 n번 반복 시 이 과
정은 종료된다.

- C언어
본 과제에서는 C언어를 사용한다. 사용된 라이브러리는 다음과 같다.
1) stdio.h (표준입출력)
2) stdlib.h (동적 할당을 위함)
3) string.h (input으로 들어오는 문자열 처리를 위해 사용)
4) math.h (pow 함수 사용 위함)

## 2. 코드의 동작
전체적인 흐름은 아래와 같다.
1) n(변수의 개수)를 입력받는다.
2) Truth value들을 string으로 입력받는다. (각 변수는 공백으로 구분한다.)
3) n에 따라 old/new/prime 버퍼를 동적할당한다.
4) 입력으로 들어온 truth value들을 new 버퍼에 집어넣는다.
5) new 버퍼를 old값으로 카피한다.
6) new 버퍼를 비워준다.
7) old 값으로 비교를 진행한다.
8) 비교에 사용되어 결과가 나온 값들은 new에, 비교가 진행되지 않은 값들은 prime에 넣는다.
9) 5)-8) 과정을 n번 반복한다.
10) 최종적으로 모인 prime을 minterm expression에 맞게 출력한다.

